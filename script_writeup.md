## Scripting 

The task: Write a script that 
- Creates 25 empty (0 KB) files. (Hint: Use the touch command.)
- The file names should be \<yourName>\<number>, \<yourName>\<number+1>, \<yourName>\<number+2>, and so on.
- Design the script so that each time you run it, it creates the next batch of 25 files with increasing numbers starting with the last or maximum number that already exists.
- Do not hard code these numbers. You need to generate them by using automation.

#### A solution

```
# /bin/bash

maxnum=`find . -maxdepth 1 -regex "\./$USER[0-9][0-9]*" | sed "s/\.\/$USER//" | sort -nr | head -n 1`

for i in `seq $(($maxnum+1)) $(($maxnum+25))`; do
   touch $USER$i
done
```
#### Breakdown of script

We want to create 25 files. That’s easy, just loop 25 times and use `touch <filename>`. The tricky thing is we need to know which number to start at, since that depends on the files that have already been created. If the largest file created is `userName42`, then we want to create `userName43` to `userName67`. We also want to ignore all other files that aren’t in the form `userName<number>`. So the question is how can we find the largest numbered file in this format? Once we do that, if we call that number `maxNumber` we just use a loop to create 25 files starting from `maxNumber+1` ending at `maxNumber+25`.

To find the highest numbered file, it would be helpful to just find all the files first without worrying about the numbers. We’re looking for files of the form `<username><number>`. How can we find files? `ls` will list all files, and we can do some basic filtering with globbing/wildcards (`*`,`?`,etc.), but for finding file names with a certain pattern, `find` is very convenient and powerful. We want to find files in the current directory, so we do `find .` (`.` means the current directory). By default `find` will explore all subdirectories, but we just want files in the current directory, so we pass the `-maxdepth 1` option to limit the search to the current directory. 

We also want to look for file names in the form `<username><number>`. Regular expressions are perfect for this, and unlike `ls`, `find` can match on a regexp. Note that the output of find for the current directory will be something like `./myFile42.txt`, (so we have to make sure to match on the `“.”` and `“/”`). The full regexp we match on `"\./$USER[0-9][0-9]*"` which just means match a period, followed by a forward slash, followed by the username (which is an environment variable) and then a number, which is just one or more digits. (This should be able to be done with `\d+` or `[0-9]+` which is a bit more concise, but this wasn’t working with my `find` or `grep` commands, so I used `[0-9][0-9]*`, which is equivalent. Note that just `[0-9]*` would match no numbers, which we don’t want. Also note the back slash escaping the `.`)

You should try this `find . -maxdepth 1 -regex "\./$USER[0-9][0-9]*` command by itself and explore the output to make sure it works as intended with various file configurations. We now want to extract the numbers from the file names so we can find the largest number. We want to use some command that finds certain text or patterns in output. `grep` does this, but finding exactly what we want can be a bit tricky. We’re looking for the numbers in our file names. So something like `grep -o [0-9]+` (or `grep -o [0-9][0-9]*` since `+` doesn't seem to work on my system). The `-o` tells `grep` to get rid of all other text except the matches (i.e. just keep the numbers which is what we want). This seems fine, and it is fine for many normal file names. 

But what if the filename or username has numbers in it? If the username for example is `ec2-user`,  and we have files `ec2-user1 ec2-user2 ec2-user3 ... ec2-user25`. The `grep` command we just wrote will match all digits, including the `2` in the username. In this situation it’s not a problem, since `2` is smaller than the largest number `25`, but what if the user was `ec26-user`? Then we `grep` would match `26`, and the largest number would be`26` even though there are only `25` files created. We could try to use `$` to match numbers only at the end of the filename/line, and that would fix this specific example, but what if the number isn't in the middle of the username like `ec2-user`, but at the end, e.g. the username is just `ec2`. Then if we create `25` files we'll have `ec21 ec22 ec23 ... ec225`. If we `grep` and match the numbers only at the end, we'll get `21 22 23 ... 225`, and the largest number will `225`. But of course we don't have anywhere near `225` files, we just have `25`.

We can see now that using `grep` to extract the numbers isn't quite as simple as it might have seemed. It's still probably possible to do so, but it might be somewhat complicated. Instead of trying to think about extracting digits, let's think about what the filenames look like, and what we want to keep, and what we want to remove. The output of `find` will look something like this `./ec2-user1 ./ec2-user2 ./ec2-user3 ... ./ec2-user25`. Instead of thinking about how we can get the digits, let's see what we don't want. We don't want to keep the `./` and twe don't want to keep `ec2-user`, the username. So instead of finding and extracting the digits, why don't we find and remove the rest of the text that we don't want. 

That's where `sed` comes in. `sed` is for editing and transforming text through the command line. One of its features is find and replace. You can think of removing text as basically finding it and replacing it with nothing. That's what `sed "s/\.\/$USER//` does. `sed` has a find and replace function which looks like this: `sed "s/<find_this>/<replace_with_this>/g"`. For each line, it replaces each occurence of the text or pattern that matches `<find_this>` with the text in `<replace_with_this>`. (The `g` stands for `global` and means it will replace all occurences in the line. Since we will only have one occurence of the username in the file name, we can leave the `g` out.) Thus what our command is saying is find all instances of `./` followed by the `username`, and replace them with `""` (blank or nothing), i.e. delete them from the text. Once we do this, we have just the file numbers leftover, like we wanted.

The rest is now pretty straightforward. After running `find` and piping the output into `sed`, we now have a list of numbers from our filenames. We want to find the biggest number, so first let's feed our output from `sed` into `sort`: `sort -nr`, (`-n` means sort numerically not alphabetically, which is what we want, and `-r` means reverse, so biggest number is the first result). After this, we'll get a list of numbers where the biggest number is the first line, so finally to get just that number, let's pipe into `head -n 1`, where `-n 1` means get the first line of output.

This final result gets put into the variable `maxnum`. What if there are no files of the form `<user><number>` in the directory? Well then the output of `find` is empty, which means the output of `sed` is empty, which means the outputs of `sort` and finally `head` are also empty. So `maxnum` will be an empty string. But in shell scripting when we do math operations with an empty string, it is treated as `0`. When we do some math with `maxnum` in the next section of the script, it will be treated as `0`, just like we would want if `find` matches no files, so the code works as intended.

The final bit of the script is simple. We know what `maxnum` is, which is the hard part. Now we just want to create `25` more files, starting from `maxnum+1` and ending at `maxnum+25`. `seq` creates a list of numbers which we can loop over. If `maxnum` is `0` or empty, then `seq $(($maxnum+1)) $(($maxnum+25))` will become `seq 1 25`, which evaluates to the list `1 2 3 ... 25`. In our loop, `i` will go through each value in this list, starting at `1` and ending at `25` and create files `<user>1 <user>2 <user>3 ... <user>25`. If we have already created these `25` files, then maxnum will be `25` and we will loop over `seq 26 50`, and create `<user>26 <user>27 <user>28 ... <user>50`. 

Note that we don't make any assumptions about the state of the directory. It could be empty, or have other files not of the form `<user><number>`. Those files will not have any effect on the script, as intended. Note that we can also delete files and it will also work as intended. If we have files `user1 user2 ... user23 user24 user25` and delete files `user1 user2`, the script will still calculate `maxnum` as `25` and create files `user26 user27 ... user50`. However, if we also delete `user24 user25`, now the largest numbered file in this form is `user23` so `maxnum` is `23` and we will instead create `25` files starting from `24`, so `user24 user25 ... user48`.


